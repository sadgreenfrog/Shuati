## 
110. Balanced Binary Tree

https://leetcode.com/problems/balanced-binary-tree/

https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.md

My Solution

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
    
  
 # 后序遍历，因为高度只能从下到上去查，栈，左右中
 # CUR节点的最大深度，就是高度
    def getDepth(self, cur):
        st = [cur]
        depth = 0
        res = 0
        while st:
            node = st.pop()
            if node: # 难道不是会 一直卡在这里吗？？
                st.append(node) # 中
                st.append(None) 
                depth += 1
                if node.right: st.append(node.right) #右
                if node.left: st.append(node.left) #左
            else: #这个条件是在找错路时候，把depth再减回到左右分叉口。
                node = st.pop()
                depth -= 1
            res = max(res,depth) #每次res都不一样的
        return res

```

## 思路想法
没想清，要再看
