## 3Sum

https://leetcode.com/problems/3sum/

My Solution

```python
Initial:
class Solution(object):
    def threeSum(self, nums):
    for i in range(n):
      r = n - 1
      l = i + 1
      if r > l:
        for l in range(i + 1, n):
            if nums[i] + nums[l] + nums[r] == 0:
                ans.append([nums[i], nums[l], nums[r]])
      r -= 1
    return ans
        
Modified:
class Solution(object):
    def threeSum(self, nums):
        nums.sort()
        n = len(nums)
        res = []
        for i in range(n):
            if nums[i] > 0: #判断如果第一个数字就大于0的话，直接return,因为不可能=0了
                return res
            if nums[i] == nums[i-1] and i>0:    #判断i和i+1是不是一样的，是的话跳出循环,continue.直接下一个i
                continue
            left = i + 1
            right = n - 1
            while left < right:
                if nums[i] + nums[left] + nums[right] > 0:   #>0，right往左边移动
                    right -= 1
                elif nums[i] + nums[left] + nums[right] < 0:  #<0, left往右边移动
                    left += 1
                else: 
                    res.append([nums[i], nums[left], nums[right]]) #=0，记录当前位置
                    while left < right and nums[left] == nums[left + 1]: #当left=left+1，跳过中间重复的
                        left += 1
                    while left < right and nums[right] == nums[right -1]:
                        right -= 1
                    left += 1
                    right -= 1
        return res

```

## 思路想法
初步的思路:并没有想到需要sort,如果不sort的话，是会有重复的值的。

sort之后，也要注意一共有三种重复,i,left,right,都要考虑进去。

7.20 - still make the same mistake as before, i use 3 for loops for a,b,c, and didn't find a good way to filter out the duplicates, as below.
 
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        count = []
        for i in range(len(nums)-2):
            for j in range(i+1, len(nums)-1):
                for q in range(i+2, len(nums)):
                    if nums[i] + nums[j] + nums[q] == 0:
                        count.append([nums[i],nums[j],nums[q]])
        return count
```
Sort the input array can eliminate the duplicate output. The reason for that is once we find two adjacent numbers are the same, we can skip the second one.

After we figure out how to select the first one a, the rest two numbers b and c, can be solved like sum2(hashmap/pointers).

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = [] # return the list of lists
        nums.sort()
        
        for i, a in enumerate(nums): # iterate through the index
            if i > 0 and a == nums[i-1]:  # i >0 means it is not the first one in the array and it is euql to the previous one
                continue                  # going to the next iteration of the loop
            
            l = i+1
            r = len(nums) - 1
            while l < r:
                threesum = a + nums[l] + nums[r]
                if threesum > 0:  # if it's larger than 0, it's going to decrease
                    r -= 1
                elif threesum < 0:
                    l += 1
                else:
                    res.append([a, nums[l], nums[r]])
                    # 怎么更新pointer是重点, r不用更新，因为上面if/elif会自动更新r，不然会漏掉一些。(控制变量??)
                    l += 1
                    while nums[l] == nums[l-1] and l < r: # 如果l和l+1重复了，那么l也像a一样移动
                        l += 1
        return res
```
