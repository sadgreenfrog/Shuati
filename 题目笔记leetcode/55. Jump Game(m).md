## 55. Jump Game

https://leetcode.com/problems/jump-game/

My Solution

```python
#-------------------------exceed time--------------------------------#
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        
        n = len(nums) - 1
        def res(pos):
        # base case: the position equal to the ending number
            if pos == n:
                return True
            maxjump = nums[pos] # The distance which can go longest
            for i in range(1, maxjump+1): # +1 because we want to add based on i
                if res(pos+i):
                    return True
            return False
        return res(0)
#---------------------------------------------------------------#
```

## 解题思路和想法
1. recursive approach: write recursive function to check at each point and every single next point that he can go and recursively call how far you can go.

这个思路其实就是dfs,穷举所有可能性，是一个n叉树。

https://leetcode-cn.com/problems/jump-game/solution/chao-xiang-xi-tu-jie-di-gui-tan-xin-55-tiao-yue-yo/

2. Memorization进行内存简化

3. 贪心算法
我们只需要维护一个最远可达的下标，然后遍历整个数组，如果数组遍历完后，这个最远可达的下标是大于等于 数组最后一个位置，那么说明最后一个位置是可达的，否则最后一个位置不可达。
