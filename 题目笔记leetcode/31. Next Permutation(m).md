##
31. Next Permutation

https://leetcode.com/problems/next-permutation/

My Solution

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        
        length = len(nums)
        pointer = length - 2
        while pointer >= 0 and nums[pointer] >= nums[pointer + 1]:
            pointer -= 1 
        # Special case: Whole array is monotone decreasing, pointer = -1
        if pointer == -1:
            return nums.reverse()
        # Find the first number i which not in monotone increasing array from the behind  
        for i in range(length - 1, pointer, -1):
            if nums[i] > nums[pointer]:# From behind to front, it's increasing
                nums[pointer], nums[i] = nums[i], nums[pointer]
                break
        nums[pointer+1: ] = reversed(nums[pointer+1: ]) 
            
        # Swap i with the least number j in (i,n)
        # reverse (i+1,n)
```
## 解题思路
下一个排列顺序，如果给定数组是降序，则说明是全排列的最后一种情况，则下一个全排列就是最初始情况。

通过原数组从末尾往前看，数字逐渐变大，到了某个数字才减小。那就从后往前找第一个比当前数字大的数字并且交换。

