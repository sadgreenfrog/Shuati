## 
300. Longest Increasing Subsequence
 
https://leetcode.com/problems/longest-increasing-subsequence/

My Solution

```python
# --------------------dynamic programming---------------------#
class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
    # 注意这题的子序列不是原封不动从原序列出来的！
    # 1.dp[i]的定义：表示i之前包括i的最长上升子序列
    # 2.dp方程: if(nums[i]>nums[j] dp[i] = max(dp[i],dp[j]+1))
    # 3.dp[i]的初始化: dp[1]=1 每一个起始大小为1
    # 4. 确定遍历顺序: dp[i]是0到i-1各个位置的最长升序子序列推导而来，遍历i一定从前往后
    # j小于i，一直follow i
    # 5.举例推导dp数组
        if len(nums) <= 1:
            return len(nums)
        dp = [1] * (len(nums)+1)
        res = 0
        for i in range(1, len(nums)):
            for j in range(0, i): # 实际i-1
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
            res = max(res, dp[i]) # 每一小轮取最长的子序列
        return res
    # i = 1时，nums[1] > nums[0], dp[0] + 1 = 2
    # i = 2时， nums[2] < nums[0]/nums[1], 不计入
    # i = 3时， nums[0]/nums[1]/nums[2] < nums[3], ==3
```
## 解题思路
dp[i]可以根据dp[j](j<i)推导出来，dp[i]表示i之前包括i的最长上升子序列。

注意这题的子序列不是原封不动从原序列出来的！

状态是可以由之前的子树列叠加上的。

