## 24. Swap Nodes in Pairs

https://leetcode.com/problems/swap-nodes-in-pairs/

My Solution

```python
#-----------------迭代--------------------------------#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummyhead = ListNode(0)
        dummyhead.next = head
        temp = dummyhead
        while temp.next or temp.next.next:
            node1 = temp.next
            node2 = temp.next.next
            temp.next = node2
            node1.next = node2.next
            node2.next = node1
            temp = node1
        return dummyhead.next
 #--------------------递归----------------------------#
# Definition for singly-linked list.

class Solution(object):
    def swapPairs(self, head):
        # 递归终止条件
        if not (head and head.next):
            return head
        tmp = head.next # 保存节点2，返回值
        
        head.next = self.swapPairs(tmp.next)
        # 2节点指向1
        tmp.next = head
        return tmp
```

## 思路想法
递归：

递归出口：当前节点或者下一个节点为空，返回.当前节点为null，或者下一个节点为 null

方法内容：当前节点next，指向当前节点，指针互换. 函数内：将 2 指向 1，1 指向下一层的递归函数，最后返回节点 2

返回值：返回交换完成的节点

递归把一层的逻辑搞清楚，后面细节就可以交给程序了

迭代：创建哑结点 dummyHead，令 dummyHead.next = head。令 temp 表示当前到达的节点，初始时 temp = dummyHead。每次需要交换 temp 后面的两个节点。

如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。




