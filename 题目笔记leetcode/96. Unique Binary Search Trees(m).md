## 
96. Unique Binary Search Trees
 
https://leetcode.com/problems/unique-binary-search-trees/

My Solution

```python
# --------------------dynamic programming---------------------#
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
    # 1. 确定dp数组以及下标的含义, 1到i为节点组成的二叉搜索树的个数。
    # 列出dp[0],dp[1],dp[2]和dp[3]， 可得出dp[3] = dp[2]*dp[0] +dp[1]*dp[1] + dp[0]*dp[2]
    # 2. 确认递推公式: dp[i] += dp[j-1] * dp[i-j]; j-1为头结点左子树节点数量，i-j为以j为头节点右子树节点数量。一层层迭代
    # 3. 初始化: dp[0] = 1, 否则乘法都为0了
    # 4. 确定遍历顺序 ifrom 1, j from 1 to i
    # 5. 举例推导
        dp = [0] * (n+1)
        dp[0] = 1 # 初始化
        for i in range(1, n+1):
            for j in range(1, i+1): # 原因是为了，让i-1时候，能有效
                dp[i] += dp[j-1] * dp[i-j]
        return dp[n]
```
## 解题思路
二叉树定义:
1. 若左子树不为空，则左子树上所有节点的值均小于根节点。
2. 若右子树不为空，则右子树所有节点值均大于根节点。
3. 左右子树分别为二叉搜索树。

所有动态规划问题需要找重叠的/重复的那个规律。

当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局是一样的。

当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的。

当2位头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的。

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量 相乘是因为排列组合

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
