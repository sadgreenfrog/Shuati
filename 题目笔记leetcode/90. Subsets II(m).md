## 
90. Subsets II

https://leetcode.com/problems/subsets-ii/

My Solution

```python
class Solution(object):
    res = []
    path = []    
    def subsetsWithDup(self, nums):
        del self.res[:]
        del self.path[:]
        nums = sorted(nums)
        self.backtrack(nums, 0)
        return self.res      
    def backtrack(self, nums, startindex):
        self.res.append(self.path[:])
        for i in range(startindex, len(nums)):
            if i > startindex and nums[i] == nums[i-1] : # 一定是要同一层 used[i-1]==true,说明同一树枝candidates[i-1]使用过/ ==false, 同一树层使用过
                continue                                 # i>startindex,保证了是同一层，因为如果是下一层, startindex 会变成i+1
            self.path.append(nums[i])
            self.backtrack(nums, i+1)
            self.path.pop()
```
## 解题思路
注意去重，和comibnation3去重方法一样。

一定是要同一层 used[i-1]==true,说明同一树枝candidates[i-1]使用过/ ==false, 同一树层使用过

i>startindex,保证了是同一层，因为如果是下一层, startindex 会变成i+1
