## 
130. Surrounded Regions
 
https://leetcode.com/problems/surrounded-regions/

My Solution

```python
"""
class Solution(object):
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        long_streak = 0
        num_set = set(nums)
        for x in num_set:
            if x-1 not in num_set: # 如果在里面，先跳过，之后会遍历到的
                count = 1 # 先把自己数上
                current_num = x
                while current_num+1 in num_set:
                    current_num += 1
                    count += 1
                long_streak = max(long_streak, count)
        return long_streak
```

## 思路想法
参照200题：number of islands:1代表小岛，0代表河水，求多少个小岛。

遍历这个矩阵，如果遇到1就进行深度优先搜索k，访问它的邻居直到都是水(0)。For every land, visit its neighbor land using DFS until there is no such land, mark every vistied node 
as 0. Then we found an island.

Connectivity: BFS/DFS/Disjoint-set can traverse the graph.

去寻找一个REGION,被包围在x里面的，标记一下/寻找没有被包围的region。Find all connected components of 'O's that has at least one 'O' is on the border, keep them as is. Then
flip all other 'O's to 1.

如何寻找和边界联通的OO? 从边界出发，对图进行 dfs 和 bfs 即可。这里简单总结下 dfs 和 dfs。

bfs 递归。可以想想二叉树中如何递归的进行层序遍历。
bfs 非递归。一般用队列存储。
dfs 递归。最常用，如二叉树的先序遍历。
dfs 非递归。一般用 stack。

对于dfs/bfs的理解，这一篇很好：https://leetcode-cn.com/problems/surrounded-regions/solution/bfsdi-gui-dfsfei-di-gui-dfsbing-cha-ji-by-ac_pipe/
## syntax
A set is an unordered collection of items. Every set element is unique (no duplicates) and must be immutable (cannot be changed).
