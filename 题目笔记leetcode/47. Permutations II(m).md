## 
47. Permutations II

https://leetcode.com/problems/permutations-ii/

My Solution

```python
class Solution:
    def permuteUnique(self, nums) :
        # res用来存放结果
        if not nums: return []
        res = []
        used = [0] * len(nums)
        def backtracking(nums, used, path):
            # 终止条件
            if len(path) == len(nums):
                res.append(path[:])
                return
            for i in range(len(nums)):
                if not used[i]:
                    if i>0 and nums[i] == nums[i-1] and not used[i-1]:
                        continue
                    used[i] = 1
                    path.append(nums[i])
                    backtracking(nums, used, path)
                    path.pop()
                    used[i] = 0
        # 记得给nums排序
        backtracking(sorted(nums),used,[])
        return res             
```
## 解题思路

同层去重: used[i-1]==true,说明同一树枝candidates[i-1]使用过/ ==false, 同一树层使用过, i>startindex,保证了是同一层，因为如果是下一层, startindex 会变成i+1

但是这里不能用startindex，因为下一层，会遍历除了自己的其他元素。

横向:once a time, 所以used[i-1] = false/0. 因为前一个一定选过了，现在变为0了。

纵向: used[i-1] = 1, 说明是在同一个树枝上
