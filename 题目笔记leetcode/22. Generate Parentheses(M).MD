## 22. Generate Parentheses

https://leetcode.com/problems/generate-parentheses/

My Solution

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # choice1: only add open paranthesis if open < n
        # choice2: only add a closing paranthesis if closed < open
        # valid if open ==closed == n
        
        stack = [] 
        res = [] # valid combination
        def backtrack(openN, closeN): # If I create the function in this function, I don't need to pass stack/res,n into it because it's nested
            if openN == closeN == n :
                res.append("".join(stack)) # Put every character in the stack and join them together into a empty string
                return
            if openN < n:
                stack.append("(")
                backtrack(openN + 1, closeN)
                stack.pop()
            if closeN < openN:
                stack.append(")")
                backtrack(openN, closeN+1)
                stack.pop()
        backtrack(0,0)
        return res
```

## 思路想法
两个添加条件:

choice1: only add open paranthesis if open < n

choice2: only add a closing paranthesis if closed < open

3 keys to backtracking: It takes a complex problem with a wide decision space and narrow it down to the choices that we make at each stack frame of our recursion, and
every stack has a state, state dictates how we act.

void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
  
